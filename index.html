<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Britannia2 ‚Äî Realm Prototype</title>
    <style>
        :root {
            color-scheme: dark;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: "Cinzel", "Segoe UI", system-ui, sans-serif;
            background: #05090f;
            color: #f4e9ce;
        }

        #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
            touch-action: none;
            outline: none;
            background: #04060b;
        }

        #loadingOverlay {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at 50% 30%, rgba(32, 52, 78, 0.92), rgba(6, 12, 20, 0.95));
            color: #f9f1dc;
            text-align: center;
            gap: 12px;
            z-index: 20;
            padding: 24px;
        }

        #loadingOverlay.hidden {
            display: none;
        }

        #loadingOverlay .title {
            font-size: clamp(1.2rem, 3vw, 2.1rem);
            letter-spacing: 0.12em;
            text-transform: uppercase;
        }

        #loadingOverlay .subtitle {
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            opacity: 0.85;
        }

        #progressBarContainer {
            width: min(360px, 80vw);
            height: 6px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.18);
            overflow: hidden;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.35) inset;
        }

        #progressBar {
            width: 0%;
            height: 100%;
            border-radius: 4px;
            background: linear-gradient(90deg, #fce38a, #f38181);
            transition: width 0.25s ease;
        }

        #errorOverlay {
            position: fixed;
            inset: 0;
            background: rgba(12, 10, 16, 0.92);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            text-align: center;
            z-index: 30;
            padding: 30px;
        }

        #errorOverlay h2 {
            margin: 0;
            font-size: clamp(1.1rem, 2.5vw, 1.8rem);
            color: #ffb4a2;
        }

        #errorOverlay p {
            margin: 0;
            max-width: 420px;
            line-height: 1.4;
        }

        #retryButton {
            padding: 10px 22px;
            border-radius: 999px;
            border: 1px solid rgba(255, 214, 153, 0.4);
            background: rgba(255, 214, 153, 0.18);
            color: #ffe8c8;
            font-size: 0.95rem;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
        }

        #retryButton:hover,
        #retryButton:focus-visible {
            background: rgba(255, 214, 153, 0.3);
            color: #fff9f0;
            outline: none;
        }

        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            display: grid;
            gap: 6px;
            padding: 14px 16px;
            width: min(280px, 40vw);
            background: rgba(8, 11, 18, 0.7);
            border: 1px solid rgba(255, 236, 201, 0.18);
            border-radius: 10px;
            color: #f6eed4;
            font-size: 0.9rem;
            line-height: 1.35;
            backdrop-filter: blur(6px);
            pointer-events: none;
            z-index: 5;
        }

        #hud h2 {
            margin: 0;
            font-size: 1.1rem;
            letter-spacing: 0.05em;
        }

        #hud p {
            margin: 0;
        }

        #hud strong {
            color: #ffd166;
            font-weight: 600;
        }

        #hud .controls {
            font-size: 0.8rem;
            opacity: 0.75;
        }

        #interactionPrompt {
            position: fixed;
            bottom: 18vh;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(14, 18, 28, 0.75);
            padding: 10px 18px;
            border-radius: 999px;
            border: 1px solid rgba(255, 228, 179, 0.35);
            color: #ffe1a8;
            font-size: 0.9rem;
            display: none;
            pointer-events: none;
            z-index: 8;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
        }

        #interactionPrompt span {
            font-weight: 700;
            color: #fff1c1;
        }

        @media (max-width: 768px) {
            #hud {
                width: min(240px, 70vw);
                font-size: 0.8rem;
                top: 12px;
                left: 12px;
            }

            #hud h2 {
                font-size: 1rem;
            }

            #interactionPrompt {
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div id="loadingOverlay" role="status" aria-live="polite">
        <div class="title">üè∞ Forging Britannia</div>
        <div id="loadingText" class="subtitle">Preparing the 3D realm...</div>
        <div id="progressBarContainer" aria-hidden="true">
            <div id="progressBar"></div>
        </div>
        <div class="subtitle" id="loadingTip">Tip: Click the world to take control of your hero.</div>
    </div>

    <div id="errorOverlay" role="alert">
        <h2>‚ö†Ô∏è The realm failed to awaken</h2>
        <p id="errorMessage">An unexpected error occurred.</p>
        <button id="retryButton" type="button">Retry</button>
    </div>

    <canvas id="gameCanvas" aria-label="Britannia 3D world"></canvas>

    <section id="hud" aria-live="polite">
        <h2>Britannia2 Explorer</h2>
        <p><strong>Position:</strong> <span id="hudPosition">0, 0</span></p>
        <p><strong>Region:</strong> <span id="hudRegion">üåæ Central Plains</span></p>
        <p><strong>Status:</strong> <span id="hudStatus">Click the realm to begin your journey.</span></p>
        <p class="controls">WASD: Move ‚Ä¢ Mouse: Look ‚Ä¢ Shift: Sprint ‚Ä¢ E: Interact</p>
    </section>

    <div id="interactionPrompt">Press <span>E</span> to inspect</div>

    <script type="module">
        import * as THREE from "https://unpkg.com/three@0.160.1/build/three.module.js";
        import { GLTFLoader } from "https://unpkg.com/three@0.160.1/examples/jsm/loaders/GLTFLoader.js?module";
        import { DRACOLoader } from "https://unpkg.com/three@0.160.1/examples/jsm/loaders/DRACOLoader.js?module";
        import { PointerLockControls } from "https://unpkg.com/three@0.160.1/examples/jsm/controls/PointerLockControls.js?module";
        import { SkeletonUtils } from "https://unpkg.com/three@0.160.1/examples/jsm/utils/SkeletonUtils.js?module";

        THREE.Cache.enabled = true;

        const MODEL_BASE_URL = "https://dmaher42.github.io/Britiannia2/assets/models/web/";

        const REGION_DEFINITIONS = [
            {
                id: "central",
                name: "Central Plains",
                label: "üåæ Central Plains",
                color: 0x6b8f3f,
                center: { x: 0, y: 0, z: 0 },
                size: { x: 180, y: 0, z: 180 },
                altitude: 0,
                buildingCountRange: [5, 8],
                buildingTemplates: [
                    { file: "plains_great_hall.glb", label: "Great Hall", scale: 1.2, spacing: 28 },
                    { file: "plains_longhouse.glb", label: "Longhouse", scale: 1.0, spacing: 24 },
                    { file: "plains_market.glb", label: "Market Stalls", scale: 0.95, spacing: 22 },
                    { file: "plains_farmstead.glb", label: "Farmstead", scale: 0.9, spacing: 20 }
                ],
                decorations: { type: "fields", rows: 3, columns: 4 }
            },
            {
                id: "woods",
                name: "Whispering Woods",
                label: "üå≤ Whispering Woods",
                color: 0x29553a,
                center: { x: -110, y: 0, z: 60 },
                size: { x: 120, y: 0, z: 120 },
                altitude: 0,
                buildingCountRange: [4, 6],
                buildingTemplates: [
                    { file: "woods_lodge.glb", label: "Forest Lodge", scale: 0.95, spacing: 24 },
                    { file: "woods_watchtower.glb", label: "Grove Watchtower", scale: 1.1, spacing: 28 },
                    { file: "woods_cabin.glb", label: "Hunter's Cabin", scale: 0.85, spacing: 20 }
                ],
                decorations: { type: "trees", count: 80 }
            },
            {
                id: "desert",
                name: "Golden Desert",
                label: "üèúÔ∏è Golden Desert",
                color: 0xcfa76b,
                center: { x: 120, y: 0, z: -80 },
                size: { x: 150, y: 0, z: 140 },
                altitude: -0.2,
                buildingCountRange: [4, 6],
                buildingTemplates: [
                    { file: "desert_caravanserai.glb", label: "Caravanserai", scale: 1.1, spacing: 30 },
                    { file: "desert_watchtower.glb", label: "Desert Watchtower", scale: 1.0, spacing: 26 },
                    { file: "desert_market.glb", label: "Mirage Bazaar", scale: 0.95, spacing: 22 }
                ],
                decorations: { type: "dunes", count: 40 }
            },
            {
                id: "swamp",
                name: "Shadowmere Swamp",
                label: "üê∏ Shadowmere Swamp",
                color: 0x27403b,
                center: { x: -120, y: 0, z: -90 },
                size: { x: 140, y: 0, z: 140 },
                altitude: -0.4,
                buildingCountRange: [3, 5],
                buildingTemplates: [
                    { file: "swamp_hut.glb", label: "Marsh Hut", scale: 0.9, spacing: 24 },
                    { file: "swamp_shrine.glb", label: "Witch's Shrine", scale: 1.0, spacing: 26 },
                    { file: "swamp_watch.glb", label: "Bog Watchtower", scale: 0.95, spacing: 24 }
                ],
                decorations: { type: "reeds", count: 70 }
            },
            {
                id: "tower",
                name: "Mystical Tower",
                label: "üè∞ Mystical Tower",
                color: 0x5b5e8c,
                center: { x: 0, y: 0, z: 60 },
                size: { x: 80, y: 0, z: 80 },
                altitude: 0.1,
                buildingCountRange: [1, 2],
                buildingTemplates: [
                    { file: "tower_main.glb", label: "Arcane Spire", scale: 1.4, spacing: 0, yOffset: 0 },
                    { file: "tower_library.glb", label: "Sage Library", scale: 1.1, spacing: 20 }
                ],
                decorations: { type: "arcane", count: 24 }
            }
        ];

        class LoadingOverlay {
            constructor() {
                this.overlay = document.getElementById('loadingOverlay');
                this.statusElement = document.getElementById('loadingText');
                this.progressBar = document.getElementById('progressBar');
                this.tipElement = document.getElementById('loadingTip');
                this.warningTimeout = null;
            }

            setStatus(message) {
                if (this.statusElement) {
                    this.statusElement.textContent = message;
                }
            }

            setProgress(value) {
                if (this.progressBar) {
                    const clamped = Math.max(0, Math.min(100, Number.isFinite(value) ? value : 0));
                    this.progressBar.style.width = `${clamped}%`;
                }
            }

            show() {
                if (this.overlay) {
                    this.overlay.classList.remove('hidden');
                }
            }

            hide() {
                if (this.overlay) {
                    this.overlay.classList.add('hidden');
                }
            }

            reportWarning(message) {
                if (!this.statusElement) {
                    return;
                }

                this.statusElement.textContent = message;
                if (this.warningTimeout) {
                    window.clearTimeout(this.warningTimeout);
                }
                this.warningTimeout = window.setTimeout(() => {
                    if (this.statusElement) {
                        this.statusElement.textContent = 'Continuing realm assembly...';
                    }
                }, 2400);
            }
        }

        class AssetLoader {
            constructor(loadingOverlay) {
                this.loadingOverlay = loadingOverlay;
                this.manager = new THREE.LoadingManager();
                this.manager.onStart = () => {
                    this.loadingOverlay.setStatus('Summoning realm assets...');
                    this.loadingOverlay.setProgress(3);
                };
                this.manager.onProgress = (url, loaded, total) => {
                    const percent = total ? (loaded / total) * 100 : Math.min(99, loaded * 10);
                    this.loadingOverlay.setProgress(percent);
                    this.loadingOverlay.setStatus(`Loading models ${loaded}/${total || '?'}...`);
                };
                this.manager.onLoad = () => {
                    this.loadingOverlay.setStatus('Finalizing structures...');
                    this.loadingOverlay.setProgress(100);
                };
                this.manager.onError = (url) => {
                    console.warn('Unable to load asset:', url);
                    this.loadingOverlay.reportWarning(`Asset missing: ${this.trimBase(url)}`);
                };
                this.gltfLoader = new GLTFLoader(this.manager);
                const dracoLoader = new DRACOLoader(this.manager);
                dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.1/examples/jsm/libs/draco/');
                this.gltfLoader.setDRACOLoader(dracoLoader);
                this.cache = new Map();
            }

            trimBase(url) {
                if (!url) {
                    return '';
                }
                return url.startsWith(MODEL_BASE_URL) ? url.slice(MODEL_BASE_URL.length) : url;
            }

            resolveUrl(relativePath) {
                if (!relativePath) {
                    return MODEL_BASE_URL;
                }
                return relativePath.startsWith('http') ? relativePath : `${MODEL_BASE_URL}${relativePath}`;
            }

            async loadModel(template = {}) {
                const relativePath = template.file || '';
                const cacheKey = relativePath;
                if (cacheKey && this.cache.has(cacheKey)) {
                    return this.cloneScene(this.cache.get(cacheKey), template);
                }

                if (!relativePath) {
                    return this.createFallback(template);
                }

                const url = this.resolveUrl(relativePath);
                try {
                    const gltf = await this.loadGLTF(url);
                    this.cache.set(cacheKey, gltf.scene);
                    return this.cloneScene(gltf.scene, template);
                } catch (error) {
                    console.warn(`Falling back to primitive for ${relativePath}`, error);
                    this.loadingOverlay.reportWarning(`Using placeholder for ${template.label || this.trimBase(relativePath)}`);
                    return this.createFallback(template, url);
                }
            }

            loadGLTF(url) {
                return new Promise((resolve, reject) => {
                    this.gltfLoader.load(url, resolve, undefined, (err) => reject(err));
                });
            }

            cloneScene(scene, template) {
                const clone = SkeletonUtils.clone(scene);
                clone.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (Array.isArray(child.material)) {
                            child.material.forEach((material) => this.prepareMaterial(material));
                        } else {
                            this.prepareMaterial(child.material);
                        }
                    }
                });
                clone.userData.sourceUrl = this.resolveUrl(template?.file || '');
                return clone;
            }

            prepareMaterial(material) {
                if (!material) {
                    return;
                }
                material.needsUpdate = true;
                if (material.map && material.map.isTexture) {
                    if ('colorSpace' in material.map) {
                        material.map.colorSpace = THREE.SRGBColorSpace;
                    }
                    material.map.anisotropy = 4;
                }
            }

            createFallback(template = {}, url = null) {
                const group = new THREE.Group();
                const baseColor = template.fallbackColor || 0xb9a67a;
                const accentColor = template.accentColor || 0x5e3a1e;

                const base = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 4, 6),
                    new THREE.MeshStandardMaterial({ color: baseColor, roughness: 0.85, metalness: 0.05 })
                );
                base.position.y = 2;
                base.castShadow = true;
                base.receiveShadow = true;

                const roof = new THREE.Mesh(
                    new THREE.ConeGeometry(4.8, 3.5, 4),
                    new THREE.MeshStandardMaterial({ color: accentColor, roughness: 0.6, metalness: 0.08 })
                );
                roof.position.y = 5;
                roof.castShadow = true;
                roof.receiveShadow = true;

                const chimney = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.4, 0.5, 2, 8),
                    new THREE.MeshStandardMaterial({ color: 0x3b2b26, roughness: 0.7 })
                );
                chimney.position.set(1.2, 4.8, 0.8);
                chimney.castShadow = true;
                chimney.receiveShadow = true;

                group.add(base);
                group.add(roof);
                group.add(chimney);
                group.name = `${template.label || 'Structure'} (Fallback)`;
                group.userData.fallback = true;
                group.userData.sourceUrl = url;
                return group;
            }
        }

        class Region {
            constructor(config) {
                this.id = config.id;
                this.name = config.name;
                this.label = config.label || config.name;
                this.color = new THREE.Color(config.color ?? 0x4c6b38);
                this.center = new THREE.Vector3(
                    config.center?.x ?? 0,
                    config.center?.y ?? config.altitude ?? 0,
                    config.center?.z ?? 0
                );
                this.size = new THREE.Vector3(
                    config.size?.x ?? 120,
                    config.size?.y ?? 0,
                    config.size?.z ?? 120
                );
                this.altitude = config.altitude ?? this.center.y ?? 0;
                this.buildingTemplates = Array.isArray(config.buildingTemplates) ? config.buildingTemplates : [];
                this.buildingCountRange = config.buildingCountRange || [3, 5];
                this.decorations = config.decorations;
                this.bounds = new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(this.center.x, this.altitude + 5, this.center.z),
                    new THREE.Vector3(this.size.x, 30, this.size.z)
                );
                this.placedPositions = [];
                this.buildingRoots = [];
            }

            async populate(scene, loader) {
                const regionGroup = new THREE.Group();
                regionGroup.name = `${this.name}Region`;
                scene.add(regionGroup);

                this.createGround(regionGroup);
                await this.addBuildings(regionGroup, loader);
                this.addDecorations(regionGroup);

                return this.buildingRoots;
            }

            createGround(parent) {
                let geometry;
                if (this.id === 'tower') {
                    geometry = new THREE.CircleGeometry(Math.max(this.size.x, this.size.z) * 0.35, 48);
                } else {
                    geometry = new THREE.PlaneGeometry(this.size.x, this.size.z, 1, 1);
                }
                const material = new THREE.MeshStandardMaterial({
                    color: this.color,
                    roughness: this.id === 'desert' ? 0.95 : 0.8,
                    metalness: 0.05
                });
                const ground = new THREE.Mesh(geometry, material);
                ground.rotation.x = -Math.PI / 2;
                ground.position.set(this.center.x, this.altitude - 0.02, this.center.z);
                ground.receiveShadow = true;
                ground.name = `${this.name}Ground`;
                parent.add(ground);
            }

            async addBuildings(parent, loader) {
                const [min, max] = this.buildingCountRange;
                const count = Math.max(0, Math.floor(Math.random() * (max - min + 1)) + min);
                const tasks = [];
                for (let i = 0; i < count; i++) {
                    const template = this.randomTemplate(i);
                    if (!template) {
                        continue;
                    }
                    const templateCopy = { ...template };
                    if (this.id === 'tower' && i === 0) {
                        templateCopy.anchorPosition = new THREE.Vector3(this.center.x, this.altitude, this.center.z);
                        templateCopy.rotation = Math.random() * Math.PI * 2;
                    }
                    tasks.push(this.loadAndConfigureBuilding(loader, templateCopy));
                }

                const loaded = await Promise.all(tasks);
                loaded.forEach((entry) => {
                    if (!entry) {
                        return;
                    }
                    const { object, template } = entry;
                    const spacing = template.spacing ?? 18;
                    const position = template.anchorPosition ? template.anchorPosition.clone() : this.samplePlacementPosition(spacing);
                    object.position.copy(position);
                    if (!template.anchorPosition) {
                        object.rotation.y = template.rotation ?? this.randomRotation();
                    } else if (template.rotation !== undefined) {
                        object.rotation.y = template.rotation;
                    }
                    object.position.y = (object.position.y ?? this.altitude) + (template.yOffset ?? 0);

                    if (template.scaleVector) {
                        object.scale.copy(template.scaleVector);
                    } else if (template.scale) {
                        object.scale.setScalar(template.scale);
                    }

                    object.userData.isBuildingRoot = true;
                    object.userData.label = template.label || 'Structure';
                    object.userData.regionId = this.id;
                    object.userData.assetFile = template.file || 'fallback';
                    object.updateMatrixWorld(true);
                    parent.add(object);
                    this.buildingRoots.push(object);
                });

                return this.buildingRoots;
            }

            async loadAndConfigureBuilding(loader, template) {
                try {
                    const object = await loader.loadModel(template);
                    return { object, template };
                } catch (error) {
                    console.error(`Unable to populate ${this.name} with ${template.file}`, error);
                    return null;
                }
            }

            addDecorations(parent) {
                if (!this.decorations) {
                    return;
                }

                switch (this.decorations.type) {
                    case 'trees':
                        this.addTreeInstances(parent, this.decorations.count ?? 60);
                        break;
                    case 'reeds':
                        this.addReedInstances(parent, this.decorations.count ?? 50);
                        break;
                    case 'dunes':
                        this.addDunes(parent, this.decorations.count ?? 30);
                        break;
                    case 'arcane':
                        this.addArcaneCrystals(parent, this.decorations.count ?? 20);
                        break;
                    case 'fields':
                        this.addFieldPatches(parent, this.decorations.rows ?? 2, this.decorations.columns ?? 3);
                        break;
                    default:
                        break;
                }
            }

            addTreeInstances(parent, count) {
                const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4.5, 6);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x3d2715, roughness: 0.85 });
                const foliageGeometry = new THREE.ConeGeometry(2.5, 4.8, 8);
                const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x1f5d32, roughness: 0.65 });

                const trunks = new THREE.InstancedMesh(trunkGeometry, trunkMaterial, count);
                const foliage = new THREE.InstancedMesh(foliageGeometry, foliageMaterial, count);
                const dummy = new THREE.Object3D();

                for (let i = 0; i < count; i++) {
                    const point = this.randomPoint(8);
                    const sizeFactor = 0.8 + Math.random() * 0.6;

                    dummy.position.set(point.x, this.altitude + 2.2, point.z);
                    dummy.scale.set(sizeFactor, sizeFactor, sizeFactor);
                    dummy.rotation.set(0, Math.random() * Math.PI * 2, 0);
                    dummy.updateMatrix();
                    trunks.setMatrixAt(i, dummy.matrix);

                    dummy.position.set(point.x, this.altitude + 4.6 * sizeFactor, point.z);
                    dummy.scale.set(sizeFactor, sizeFactor, sizeFactor);
                    dummy.rotation.set(0, Math.random() * Math.PI * 2, 0);
                    dummy.updateMatrix();
                    foliage.setMatrixAt(i, dummy.matrix);
                }

                trunks.castShadow = false;
                trunks.receiveShadow = true;
                foliage.castShadow = true;
                foliage.receiveShadow = true;
                trunks.instanceMatrix.needsUpdate = true;
                foliage.instanceMatrix.needsUpdate = true;

                parent.add(trunks);
                parent.add(foliage);
            }

            addReedInstances(parent, count) {
                const stalkGeometry = new THREE.CylinderGeometry(0.15, 0.2, 2.6, 5);
                const stalkMaterial = new THREE.MeshStandardMaterial({ color: 0x4a6a3a, roughness: 0.75 });
                const reeds = new THREE.InstancedMesh(stalkGeometry, stalkMaterial, count);
                const dummy = new THREE.Object3D();

                for (let i = 0; i < count; i++) {
                    const point = this.randomPoint(4);
                    const scale = 0.8 + Math.random() * 0.5;
                    dummy.position.set(point.x, this.altitude + 1.3, point.z);
                    dummy.scale.setScalar(scale);
                    dummy.rotation.set(Math.random() * 0.3, Math.random() * Math.PI * 2, 0);
                    dummy.updateMatrix();
                    reeds.setMatrixAt(i, dummy.matrix);
                }

                reeds.castShadow = false;
                reeds.receiveShadow = true;
                reeds.instanceMatrix.needsUpdate = true;
                parent.add(reeds);
            }

            addDunes(parent, count) {
                const duneGeometry = new THREE.SphereGeometry(4, 12, 12);
                const duneMaterial = new THREE.MeshStandardMaterial({ color: 0xdcb67a, roughness: 0.95, metalness: 0.02 });
                for (let i = 0; i < count; i++) {
                    const dune = new THREE.Mesh(duneGeometry, duneMaterial);
                    const point = this.randomPoint(12);
                    const scale = 0.8 + Math.random() * 1.4;
                    dune.scale.set(1.8 * scale, 0.6 * scale, 1.4 * scale);
                    dune.position.set(point.x, this.altitude + 1.2 * (scale - 0.6), point.z);
                    dune.castShadow = false;
                    dune.receiveShadow = true;
                    dune.rotation.y = Math.random() * Math.PI;
                    parent.add(dune);
                }
            }

            addArcaneCrystals(parent, count) {
                const crystalGeometry = new THREE.OctahedronGeometry(1.2, 0);
                const crystalMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8c9bff,
                    emissive: 0x3a4aff,
                    emissiveIntensity: 0.4,
                    roughness: 0.35,
                    metalness: 0.2
                });

                for (let i = 0; i < count; i++) {
                    const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                    const point = this.randomPoint(10);
                    const scale = 0.6 + Math.random() * 0.9;
                    crystal.scale.setScalar(scale);
                    crystal.position.set(point.x, this.altitude + 0.8 + Math.sin(i) * 0.2, point.z);
                    crystal.rotation.y = Math.random() * Math.PI * 2;
                    crystal.rotation.x = Math.random() * 0.6;
                    crystal.castShadow = true;
                    crystal.receiveShadow = true;
                    parent.add(crystal);
                }
            }

            addFieldPatches(parent, rows, columns) {
                const width = this.size.x * 0.65;
                const depth = this.size.z * 0.65;
                const spacingX = width / Math.max(1, columns);
                const spacingZ = depth / Math.max(1, rows);

                const patchGeometry = new THREE.PlaneGeometry(spacingX * 0.8, spacingZ * 0.8);
                const patchMaterial = new THREE.MeshStandardMaterial({
                    color: 0xb69b5b,
                    roughness: 0.9,
                    metalness: 0.05
                });

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < columns; col++) {
                        const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                        const offsetX = (col - (columns - 1) / 2) * spacingX;
                        const offsetZ = (row - (rows - 1) / 2) * spacingZ;
                        patch.rotation.x = -Math.PI / 2;
                        patch.position.set(this.center.x + offsetX, this.altitude - 0.01, this.center.z + offsetZ);
                        patch.receiveShadow = true;
                        parent.add(patch);
                    }
                }
            }

            randomTemplate(index) {
                if (!this.buildingTemplates.length) {
                    return null;
                }
                const template = this.buildingTemplates[index % this.buildingTemplates.length];
                if (index < this.buildingTemplates.length) {
                    return { ...template };
                }
                const randomIndex = Math.floor(Math.random() * this.buildingTemplates.length);
                return { ...this.buildingTemplates[randomIndex] };
            }

            randomRotation() {
                return Math.random() * Math.PI * 2;
            }

            samplePlacementPosition(minDistance) {
                const attempts = 20;
                const radiusX = Math.max(8, this.size.x / 2 - 6);
                const radiusZ = Math.max(8, this.size.z / 2 - 6);

                for (let i = 0; i < attempts; i++) {
                    const candidate = new THREE.Vector3(
                        this.center.x + (Math.random() * 2 - 1) * radiusX,
                        this.altitude,
                        this.center.z + (Math.random() * 2 - 1) * radiusZ
                    );
                    const tooClose = this.placedPositions.some((pos) => pos.distanceToSquared(candidate) < minDistance * minDistance);
                    if (!tooClose) {
                        this.placedPositions.push(candidate.clone());
                        return candidate;
                    }
                }

                const fallback = new THREE.Vector3(
                    this.center.x + (Math.random() * 2 - 1) * radiusX,
                    this.altitude,
                    this.center.z + (Math.random() * 2 - 1) * radiusZ
                );
                this.placedPositions.push(fallback.clone());
                return fallback;
            }

            randomPoint(edgePadding = 6) {
                const radiusX = Math.max(4, this.size.x / 2 - edgePadding);
                const radiusZ = Math.max(4, this.size.z / 2 - edgePadding);
                return new THREE.Vector3(
                    this.center.x + (Math.random() * 2 - 1) * radiusX,
                    this.altitude,
                    this.center.z + (Math.random() * 2 - 1) * radiusZ
                );
            }

            contains(position) {
                return this.bounds.containsPoint(position);
            }
        }

        class RegionManager {
            constructor(scene, loader, overlay) {
                this.scene = scene;
                this.loader = loader;
                this.overlay = overlay;
                this.regions = REGION_DEFINITIONS.map((config) => new Region(config));
                this.interactables = [];
            }

            async buildWorld() {
                const interactables = [];
                for (const region of this.regions) {
                    this.overlay.setStatus(`Populating ${region.name}...`);
                    const buildings = await region.populate(this.scene, this.loader);
                    interactables.push(...buildings);
                }
                this.interactables = interactables;
                return interactables;
            }

            getRegionLabel(position) {
                const region = this.regions.find((entry) => entry.contains(position));
                return region ? region.label : 'Uncharted Wilds';
            }
        }

        class PlayerController {
            constructor(camera, canvas, scene) {
                this.camera = camera;
                this.canvas = canvas;
                this.scene = scene;
                this.controls = new PointerLockControls(camera, canvas);
                this.scene.add(this.controls.getObject());
                this.moveState = {
                    forward: false,
                    backward: false,
                    left: false,
                    right: false,
                    sprint: false
                };
                this.speed = 18;
                this.sprintMultiplier = 1.6;
                this.listeners = {
                    keydown: this.onKeyDown.bind(this),
                    keyup: this.onKeyUp.bind(this)
                };
                document.addEventListener('keydown', this.listeners.keydown);
                document.addEventListener('keyup', this.listeners.keyup);
            }

            setPosition(position) {
                this.controls.getObject().position.copy(position);
            }

            setInteractionHandler(handler) {
                this.interactionHandler = handler;
            }

            setLockCallbacks(onLock, onUnlock) {
                if (onLock) {
                    this.controls.addEventListener('lock', onLock);
                }
                if (onUnlock) {
                    this.controls.addEventListener('unlock', onUnlock);
                }
            }

            lock() {
                this.controls.lock();
            }

            unlock() {
                this.controls.unlock();
            }

            dispose() {
                document.removeEventListener('keydown', this.listeners.keydown);
                document.removeEventListener('keyup', this.listeners.keyup);
            }

            isLocked() {
                return this.controls.isLocked;
            }

            onKeyDown(event) {
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        this.moveState.forward = true;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        this.moveState.backward = true;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        this.moveState.left = true;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        this.moveState.right = true;
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        this.moveState.sprint = true;
                        break;
                    case 'KeyE':
                        if (!event.repeat && typeof this.interactionHandler === 'function') {
                            this.interactionHandler();
                        }
                        break;
                    default:
                        break;
                }
            }

            onKeyUp(event) {
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        this.moveState.forward = false;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        this.moveState.backward = false;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        this.moveState.left = false;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        this.moveState.right = false;
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        this.moveState.sprint = false;
                        break;
                    default:
                        break;
                }
            }

            update(delta) {
                const object = this.controls.getObject();
                if (this.controls.isLocked) {
                    const forward = (this.moveState.forward ? 1 : 0) - (this.moveState.backward ? 1 : 0);
                    const strafe = (this.moveState.right ? 1 : 0) - (this.moveState.left ? 1 : 0);
                    if (forward !== 0 || strafe !== 0) {
                        const direction = new THREE.Vector3(strafe, 0, forward).normalize();
                        const speed = this.speed * (this.moveState.sprint ? this.sprintMultiplier : 1);
                        this.controls.moveRight(direction.x * speed * delta);
                        this.controls.moveForward(direction.z * speed * delta);
                    }
                }

                object.position.y = 2;
                object.position.x = THREE.MathUtils.clamp(object.position.x, -220, 220);
                object.position.z = THREE.MathUtils.clamp(object.position.z, -220, 220);
                return object.position;
            }
        }

        class BritanniaGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.hudPosition = document.getElementById('hudPosition');
                this.hudRegion = document.getElementById('hudRegion');
                this.hudStatus = document.getElementById('hudStatus');
                this.interactionPrompt = document.getElementById('interactionPrompt');
                this.errorOverlay = document.getElementById('errorOverlay');
                this.errorMessage = document.getElementById('errorMessage');
                this.retryButton = document.getElementById('retryButton');
                this.loadingOverlay = new LoadingOverlay();
                this.clock = new THREE.Clock();
                this.raycaster = new THREE.Raycaster();
                this.focusedBuilding = null;
                this.interactableObjects = [];
                this.statusTimeout = null;
                this.isPaused = false;
                this.tempPosition = new THREE.Vector3();
                this.tempDirection = new THREE.Vector3();

                if (this.retryButton) {
                    this.retryButton.addEventListener('click', () => window.location.reload());
                }
            }

            async init() {
                try {
                    this.loadingOverlay.show();
                    this.loadingOverlay.setStatus('Initializing renderer...');
                    this.setupRenderer();
                    this.setupScene();
                    this.setupLights();

                    this.assetLoader = new AssetLoader(this.loadingOverlay);
                    this.regionManager = new RegionManager(this.scene, this.assetLoader, this.loadingOverlay);

                    this.loadingOverlay.setStatus('Shaping Britannia regions...');
                    this.interactableObjects = await this.regionManager.buildWorld();

                    this.setupPlayer();
                    this.setupEvents();

                    this.loadingOverlay.setStatus('Britannia is ready. Click to enter.');
                    this.loadingOverlay.setProgress(100);
                    window.setTimeout(() => this.loadingOverlay.hide(), 600);

                    this.animate();
                } catch (error) {
                    console.error('Game initialization failed:', error);
                    this.showError(`Initialization failed: ${error.message}`);
                }
            }

            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: true,
                    powerPreference: 'high-performance'
                });
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.75));
                this.renderer.setSize(window.innerWidth, window.innerHeight, false);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputColorSpace = THREE.SRGBColorSpace;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.08;
                this.renderer.useLegacyLights = false;
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0b1d2d);
                this.scene.fog = new THREE.FogExp2(0x0b1d2d, 0.0022);

                const baseGround = new THREE.Mesh(
                    new THREE.PlaneGeometry(520, 520),
                    new THREE.MeshStandardMaterial({ color: 0x1e2732, roughness: 1, metalness: 0 })
                );
                baseGround.rotation.x = -Math.PI / 2;
                baseGround.position.y = -0.6;
                baseGround.receiveShadow = true;
                this.scene.add(baseGround);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 6, 20);
            }

            setupLights() {
                const hemiLight = new THREE.HemisphereLight(0xe3f6ff, 0x24160b, 0.55);
                this.scene.add(hemiLight);

                const sunLight = new THREE.DirectionalLight(0xfff4d3, 1.25);
                sunLight.position.set(-60, 90, 40);
                sunLight.castShadow = true;
                sunLight.shadow.mapSize.set(2048, 2048);
                sunLight.shadow.camera.left = -220;
                sunLight.shadow.camera.right = 220;
                sunLight.shadow.camera.top = 220;
                sunLight.shadow.camera.bottom = -220;
                sunLight.shadow.camera.near = 20;
                sunLight.shadow.camera.far = 320;
                this.scene.add(sunLight);

                const towerGlow = new THREE.PointLight(0x8898ff, 1.6, 120);
                towerGlow.position.set(0, 30, 60);
                this.scene.add(towerGlow);
            }

            setupPlayer() {
                this.playerController = new PlayerController(this.camera, this.renderer.domElement, this.scene);
                this.playerController.setPosition(new THREE.Vector3(0, 2, 60));
                this.playerController.setInteractionHandler(() => this.handleInteraction());
                this.playerController.setLockCallbacks(
                    () => this.updateStatus('Exploring Britannia...'),
                    () => this.updateStatus('Click the realm to continue exploring.')
                );

                this.renderer.domElement.addEventListener('click', () => {
                    if (!this.playerController.isLocked()) {
                        this.playerController.lock();
                    }
                }, { passive: true });
            }

            setupEvents() {
                window.addEventListener('resize', () => this.onResize());
                document.addEventListener('visibilitychange', () => this.onVisibilityChange());
            }

            onResize() {
                if (!this.renderer || !this.camera) {
                    return;
                }
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.75));
                this.renderer.setSize(window.innerWidth, window.innerHeight, false);
            }

            onVisibilityChange() {
                this.isPaused = document.hidden;
                if (!this.isPaused) {
                    this.clock.getDelta();
                }
            }

            animate() {
                this.renderer.setAnimationLoop(() => {
                    const delta = this.clock.getDelta();
                    if (!this.isPaused) {
                        const position = this.playerController.update(delta);
                        this.updateHUD(position);
                        this.updateInteraction();
                    }
                    this.renderer.render(this.scene, this.camera);
                });
            }

            updateHUD(position) {
                if (!position) {
                    return;
                }
                if (this.hudPosition) {
                    this.hudPosition.textContent = `${position.x.toFixed(1)}, ${position.z.toFixed(1)}`;
                }
                if (this.hudRegion) {
                    const regionLabel = this.regionManager.getRegionLabel(position);
                    this.hudRegion.textContent = regionLabel;
                }
            }

            updateInteraction() {
                if (!this.playerController || !this.playerController.isLocked()) {
                    this.hideInteractionPrompt();
                    return;
                }

                if (!this.interactableObjects || this.interactableObjects.length === 0) {
                    this.hideInteractionPrompt();
                    return;
                }

                const origin = this.camera.getWorldPosition(this.tempPosition);
                const direction = this.tempDirection.set(0, 0, -1).applyQuaternion(this.camera.quaternion).normalize();
                this.raycaster.set(origin, direction);
                this.raycaster.far = 18;

                const intersections = this.raycaster.intersectObjects(this.interactableObjects, true);
                if (intersections.length === 0) {
                    this.hideInteractionPrompt();
                    return;
                }

                const { object, distance } = intersections[0];
                if (distance > 14) {
                    this.hideInteractionPrompt();
                    return;
                }

                const buildingRoot = this.findBuildingRoot(object);
                if (!buildingRoot) {
                    this.hideInteractionPrompt();
                    return;
                }

                this.focusedBuilding = buildingRoot;
                if (this.interactionPrompt) {
                    this.interactionPrompt.style.display = 'block';
                    const label = buildingRoot.userData.label || 'structure';
                    this.interactionPrompt.innerHTML = `Press <span>E</span> to inspect ${label}`;
                }
            }

            hideInteractionPrompt() {
                this.focusedBuilding = null;
                if (this.interactionPrompt) {
                    this.interactionPrompt.style.display = 'none';
                }
            }

            findBuildingRoot(object) {
                let current = object;
                while (current && !current.userData?.isBuildingRoot) {
                    current = current.parent;
                }
                return current && current.userData?.isBuildingRoot ? current : null;
            }

            handleInteraction() {
                if (!this.focusedBuilding) {
                    this.updateStatus('Nothing of interest nearby.');
                    return;
                }
                const label = this.focusedBuilding.userData.label || 'Structure';
                const asset = this.focusedBuilding.userData.assetFile || 'mystery';
                const statusMessage = `Inspecting ${label} (${asset})`;
                this.updateStatus(statusMessage);
            }

            updateStatus(message) {
                if (!this.hudStatus) {
                    return;
                }
                this.hudStatus.textContent = message;
                if (this.statusTimeout) {
                    window.clearTimeout(this.statusTimeout);
                }
                this.statusTimeout = window.setTimeout(() => {
                    if (this.hudStatus) {
                        this.hudStatus.textContent = 'Exploring Britannia...';
                    }
                }, 4500);
            }

            showError(message) {
                if (this.loadingOverlay) {
                    this.loadingOverlay.hide();
                }
                if (this.errorMessage) {
                    this.errorMessage.textContent = message;
                }
                if (this.errorOverlay) {
                    this.errorOverlay.style.display = 'flex';
                }
            }
        }

        const launchGame = () => {
            const game = new BritanniaGame();
            game.init();
            window.britanniaGame = game;
        };

        if (document.readyState === 'loading') {
            window.addEventListener('DOMContentLoaded', launchGame);
        } else {
            launchGame();
        }
    </script>
</body>
</html>
